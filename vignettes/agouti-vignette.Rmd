---
title: "An introduction to the AGOUti package"
output:
   rmarkdown::html_vignette:
     toc: true
     toc_depth: 3
vignette: >
  %\VignetteIndexEntry{An introduction to the AGOUti package}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=8, fig.height = 6
)
```

# Introduction

This vignette describes the use of the **AGOUti** R package, a generic R
package for exploratory analyses of multi-resolution data.

Install **AGOUti** using:
```r
#install.packages('agouti') # probs use github
```
## What is multi-resolution data and why are standard exploratory analyses difficult

Multi-resolution data is also referred to as mixed frequency, mixed data and mis-aligned data. Examples of multi-resolution data can be found in various fields including epidemiology and econometrics. The key characteristic of multi-resolution data is that the response variable/s are at a lower resolution to the covariate/s. 

Examples of multi-resoltion data include an outcome of daily deaths of respiratory disease with covariates recorded hourly or an outcome may be the number of deaths in a country with covariates at 5kmx5km resolution. Another, less intuitive example of multi-resolution data is that of a series of lagged variables. For example, daily growth in stock prices, the main covariate is the lagged growth rate. Instead of treating each lag as separate variables they can be treated as a single variable where one response, stock growth on day X, has Y lags associated (i.e. more than one covariate value for the same response).

Currently, users of multi-resolution data have to seek out separate R packages depending on each use case. For example, with spatial data you could use the `disaggregation` package, for econometric data there is `MIDAS` and for time-series data with lags there is `dlnm`. These packages provide complex statistical models and **AGOUti** does not replace these packages but rather is a more generalised package that can help users with more varied types of multi-resolution data in the preliminary stages of analyses. **AGOUti** provides generic functions for multi-resolution data that help format, summarise, visualise and carry out simple exploratory analyses.

Data visualisation is a difficult problem with aggregated outputs. 
Even standard plots like scatter plots do not work because there are many covariate
values for each response value.
Simple plots, like using the aggregate output value for all covariate values 
don't make much sense.
There are two particular problems that the **AGOUti** package visualizations address.
Firstly, the methods are scalable to hundreds or thousands of aggregate output data points. Secondly, the methods can help to detect the importance of non-linearity. 

## Key functions and how to use this vignette

The key functions of **AGOUti** are `as_disag`, `agouti_summary`, plotting and `agoutiGLM`. The function `as_disag()` takes multi-resolution data with various structures formats it and makes it of class `as_disag`. The second feature is to summarise, `agouti_summary()` takes an object of class `as_disag` and provides a summary of all high-resolution variables. Visualisation is the third feature. **AGOUti** provides four plotting functions to investigate high-resolution covariates against a low-resolution response. The final feature is to run a simple analysis with `agoutiGLM`.

This vignette will demonstrate examples of using the **AGOUti** package with
multi-resolution data of different formats. We advise readers work through the first example irrespective of the data structure in their own dataset before proceeding to the example most similar to their data.

## Examples:

1.  You think you have a single tidy dataframe
2.  Timeseries data with a lagged covariate
3.  Spatial data including shapefiles and rasters

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(SpatialEpi)
library(sf)
library(terra)
library(ggplot2)
library(raster)

devtools::load_all()
#install.packages("agouti")
#library(agouti)
```

### Example 1: You think you have a single tidy dataframe

In this example, you think your data is already tidy. You have your high resolution covariate/s, low resolution response and an ID variable linking high and low resolution data in a single dataframe. 

An example, data set in this format is provided with **AGOUti**.
The `madagascar_malaria` data has low resolution response variables of cases and case rate of malaria in different districts of Madagascar:

```{r}
data(madagascar_malaria)
knitr::kable(head(madagascar_malaria), digits=2)
```

This dataset contains the following variables:

-   `ID` an identifying value that is at the level of the response (i.e. district)
-   `cellid` an identifying value at the resolution of the covariates
-   `cases` and `case_rate` these are our response variables and within
    the same ID all response values are the same
-   `pop` population size at the resolution of cellid
-   `agg_pop` population aggregated to the resolution of ID
-   `Elevation`:`LSTmean` potential covariates (Elevation, Enhanced
    vegetation index and Land surface temperature mean)
-   `longitude`:`latitude` other spatial identifying information

#### Format

To check if this is in the correct format and to convert it to the correct format if not, we use the function `as_disag()`

```{r}
disag_data <- agouti::as_disag(madagascar_malaria, response_var="case_rate")
class(madagascar_malaria)
class(disag_data)
knitr::kable(head(disag_data), digits=2)
```

In this example, the data was already in the correct format so the returned object 
`disag_data` is in the same format as `madagascar_malaria` but the class of
the resulting dataframe has changed.

NOTE: the low-resolution response variable is repeated for all rows with the same ID.

Now we have an object of class `as_disag` we can summarise, plot and run
a simple analysis.

#### Summarise

Using the function `agouti_summary()` we can summarise the
variables that are at a higher resolution than the response. Because the raw data was already in the correct format you can use this raw data in `agouti_summary` however, a warning will be printed to encourage you to first use `as_disag()`.

```{r}
agouti::agouti_summary(disag_data)
```

This summary shows the number of rows in our dataset. This represents
the resolution of the covariates. These covariates
fall within 109 *groups* delineated the ID variable. There are a range
of group sizes from a group with only a single row of covariates to a
group with 867 rows of covariates

The default in this function summarises all variables that are not aggregated, calculated the median within each group and then presents the median of these
medians. Alternatively you can specify which variables to summarise with the argument `high_res`. For example, to summarise just the population and EVI variables:

```{r}
agouti::agouti_summary(disag_data, high_res=c("pop","EVI"))
```

#### Visualise

The **AGOUti** package provides four plotting functions

##### 1) `heat_hist()`

First of all we might be interested to look at the coviarates in isolation. The function `heat_hist()` plots a histogram grouped by ID on
the y axis ordered by the median covariate value within each group. 

Using `heat_hist` to look in turn at each of the climatic covariates in the madagascar_malaria data set:

::: {style="margin-bottom:50px;"}
```{r}
agouti::heat_hist(disag_data$Elevation, disag_data$ID)+ ggplot2::ggtitle("Elevation")
agouti::heat_hist(disag_data$EVI, disag_data$ID)+ ggplot2::ggtitle("EVI")
agouti::heat_hist(disag_data$LSTmean, disag_data$ID)+ ggplot2::ggtitle("LSTmean")
```
:::

##### 2) `group_summary_plot()`

With `heat_hist` we looked at the covariates in isolation but we might
want to visualise the covariates against the response.
`group_summary_plot()` summarises the covariates within a group (ID) by quantile and then plots these quantiles against the response data with a trend line.

::: {style="margin-bottom:50px;"}
```{r}
agouti::group_summary_plot(case_rate ~ LSTmean, data = disag_data, ID = ID, weights = pop)
```
:::

##### 3) `thresh_sm()`

An alternative way of visualizing the covariates and response is via small multiple with the function `thresh_sm()`.
The plot is created by calculating, within each
group, the proportion of observations that are above a threshold. A
scatter plot with a linear model is then plotted of the relationship between
this proportion and the aggregated output. The threshold is varied and
small multiples of the different values are plotted. The number of
multiples can be selected by the argument *small_mult*, the default is
six.

::: {style="margin-bottom:50px;"}
```{r}
agouti::thresh_sm(case_rate ~ LSTmean, data = disag_data, ID = ID, weights = pop)
```
:::

##### 4) `link_plot()`

The final plotting function available is `link_plot()`. This is a
scatter plot with data from the aggregate unit "linked" by a line and
colour coded to match.

::: {style="margin-bottom:50px;"}
```{r}
agouti::link_plot(case_rate ~ LSTmean, data = disag_data, ID = ID, weights = pop)
```
:::

#### Model

As preliminary analyses a simple glm can be fitted using `agoutiGLM`.

```{r}
agouti::agoutiGLM(case_rate ~ LSTmean, data = madagascar_malaria, ID = madagascar_malaria$ID, weights = madagascar_malaria$pop,inner_link = 'identity', outer_link = 'identity', family = 'gaussian')
```

### Example 2: Timeseries data with a lagged covariate

In this example, your data is a timeseries of class *ts*. An example is
of daily stock growth

```{r}
data("stock_vector")
knitr::kable(head(stock_vector), digits=6)
class(stock_vector)
```

This dataset contains a single variable of class *ts*, representing daily stock growth. Daily stock growth is a function of the previous days stock growth as well as the day before that. So we can create a lagged growth variable that represents our predictor. Where, each lag considered represents a different value for the predictor all corresponding to the same outcome value.

#### Format
This dataset can be transformed to the required format using the `as_disag()` function and specifying the number of lags to be considered as follows:

```{r}
disag_ts <- agouti::as_disag(stock_vector, lags=10)
class(disag_ts)
knitr::kable(head(disag_ts), digits=6)
```

#### Summarise

Using the function `agouti_summary()` we can summarise the
variables that are at a higher resolution than the outcome.

```{r}
agouti::agouti_summary(disag_ts,high_res="covariate")
```

This summary shows the number of rows in our dataset which is at the high resolution of the covariate. The covaraite falls within 4570 groups delineated by the ID variable and which represents the number of rows in the original dataset i.e. the low resolution outcome variable.

The table summarises all variables that are not aggregated, calculated the median within each group and then presents the median of these medians.

In this dataset, because we created 10 lags for every outcome value the first 10 outcomes contain NAs for some lags. As a result, the lagged growth variable summary has NAs. To consider the summary without the rows containing NA, add the argument *removeNA = TRUE*.

```{r}
agouti::agouti_summary(disag_ts,high_res="covariate",removeNA=TRUE)
```

#### Visualise

##### 1) `heat_hist()`

This data set contains a single covariate. The function
`heat_hist()` plots a histogram grouped by ID on the y axis ordered by
the median predictor (x) within each group.

::: {style="margin-bottom:50px;"}
```{r}
agouti::heat_hist(disag_ts$covariate, disag_ts$ID)+ ggplot2::ggtitle("Covariate")
```
:::

##### 2) `group_summary_plot()`

To plot the predictor against the response we can use
`group_summary_plot()`. This summarises the covariate/s by quantile and
then plots these quantiles against the response data.

::: {style="margin-bottom:50px;"}
```{r}
agouti::group_summary_plot(outcome ~ covariate, data = disag_ts, ID = ID)
```
:::

##### 3) `thresh_sm()`

An alternative way of visualising the covariates and response is via the
function `thresh_sm()`. The plot is created by calculating, within each
group, the proportion of observations that are above a threshold. A
scatter plot with a linear model is plotted of the relationship between
this proportion and the aggregated output. The threshold is varied and
small multiples of the different values are plotted. The number of
multiples can be selected by the argument *small_mult*, the default is
six.

The stock data has some NA values, any rows with NA will be removed for plotting

::: {style="margin-bottom:50px;"}
```{r}
agouti::thresh_sm(outcome ~ covariate, data = disag_ts, ID = ID, small_mult=6)
```
:::

##### 4) `link_plot()`

The final plotting function available is `link_plot()`. This is a
scatter plot with data from the aggregate unit "linked" by a line and
colour coded to match.

::: {style="margin-bottom:50px;"}
```{r}
agouti::link_plot(outcome ~ covariate, data = disag_ts, ID = ID, weights = 1)
```
:::

#### Model


### Example 3: Spatial data including shapefiles and rasters

In this example you have a response variable that relates to polygons (often geographical  administrative units such as counties in the UK). Your covariates are high-resolution rasters and you first need to extract the relevant information from your rasters along with the identifying polygon information.

Here we have two datasets 1) A shapefile (using data from the package `SpatialEpi` containing the polygons that are at the resolution of the response variable. 2) A raster or raster stack of high-resolution covariates. These raster covariates contain many pixels within a single polygon and each pixel has a value associated


```{r}
# get polygon data from SpatialEpi pacakge
polygons <- sf::st_as_sf(NYleukemia$spatial.polygon)
df <- cbind(polygons, NYleukemia$data)
ggplot2::ggplot() + ggplot2::geom_sf(data = df, aes(fill = cases / population)) + ggplot2::scale_fill_viridis_c(lim = c(0, 0.003))+ggtitle("Low-resolution polygons")
# get raster data (using annual mean temp from bioclim cropped to the extent of the polygons)
covariate <- terra::rast("annual_mean_temp_newyork.tif")
covariate_clip <- raster::crop(covariate, raster::extent(polygons))
covariate_clip <- raster::mask(covariate_clip, polygons)
plot(covariate_clip, main="High-resolution covariate")
```


#### Format

This dataset can be transformed to the required format using the `as_disag()` function:

```{r}
names(df)[1] <-"ID"
disag_sf <- agouti::as_disag(data=df, rstack=covariate, response_var="cases")
class(disag_sf)
knitr::kable(tail(disag_sf), digits=2)
```

#### Summarise

Using the function `agouti_summary()` we can summarise the
variables that are at a higher resolution than the response. In this example, some groups are of size 1 so we need to specify the names of the covariates.

```{r}
agouti::agouti_summary(disag_sf,high_res="annual_mean_temp_newyork")
```

This summary shows the number of rows in our dataset. The covaraite falls within 281 groups delineated by the ID variable and which represents the number of rows in the original dataset i.e. the low resolution response variable. The group sizes are varied in this dataset but the annual mean temperature is not so varied.

#### Visualise

##### 1) `heat_hist()`

This data set contains a single covariate. The function
`heat_hist()` plots a histogram grouped by ID on the y axis ordered by
the median predictor (x) within each group.

::: {style="margin-bottom:50px;"}
```{r}
agouti::heat_hist(disag_sf$annual_mean_temp_newyork, disag_sf$ID)+ ggplot2::ggtitle("Covariate")
```
:::

##### 2) `group_summary_plot()`

To plot the covariate against the response we can use
`group_summary_plot()`. This summarises the covariate/s by quantile and
then plots these quantiles against the response data.

::: {style="margin-bottom:50px;"}
```{r}
agouti::group_summary_plot(cases ~ annual_mean_temp_newyork, data = disag_sf, ID = ID)
```
:::

##### 3) `thresh_sm()`

An alternative way of visualising the covariates and response is via the
function `thresh_sm()`. The plot is created by calculating, within each
group, the proportion of observations that are above a threshold. A
scatter plot with a linear model is plotted of the relationship between
this proportion and the aggregated output. The threshold is varied and
small multiples of the different values are plotted. The number of
multiples can be selected by the argument *small_mult*, the default is
six.

::: {style="margin-bottom:50px;"}
```{r}
agouti::thresh_sm(cases ~ annual_mean_temp_newyork, data = disag_sf, ID = ID)
```
:::

##### 4) `link_plot()`

The final plotting function available is `link_plot()`. This is a
scatter plot with data from the aggregate unit "linked" by a line and
colour coded to match.

::: {style="margin-bottom:50px;"}
```{r}
agouti::link_plot(cases ~ annual_mean_temp_newyork, data = disag_sf, ID = ID, weights = 1)
```
:::

#### Model
